#include <iostream>
#include <bitset>

using namespace std;

int main()
{
	bool bValue = false;
	int iValue = 0;
	float fValue = 0.0f;

	/*****************************************
	* 연산자 (Operator)
	*
	* 숫자를 더하거나 빼는 등 다양한 수학 연산
	* 일반적 수학 연산과 유사한 연산자들이 지원됨
	******************************************/

	
	/*************************************************************
	* 산술 연산자
	**************************************************************/

	// <이진 연산자>
	iValue = 1 + 2;		// + (더하기)
	iValue = 3 - 1;		// - (빼기)
	iValue = 4 * 2;		// * (곱하기)
	fValue = 5.f / 3.f; // / (나누기) : 주의! 5/3과 같이 정수형 나눗셈은 소수점 버림
	iValue = 13 % 3;	// % (나머지) : a-(a/b)*b 와 동일

	// <단항 연산자>
	iValue = +iValue;	// + 단항 연산자(양수) : 값을 반환
	iValue = -iValue;; 	// - 단항 연산자(음수) : 값의 마이너스를 반환;
	++iValue;			// ++ 전위 증가 연산자 : 값을 1 증가
	iValue++;			// ++ 후위 증가 연산자 : 값을 1 증가
	--iValue;			// -- 전위 감소 연산자 : 값을 1 감소
	iValue--;			// -- 후위 감소 연산자 : 값을 1 감소

	// <전위 연산자와 후위 연산자>
	// 전위 연산자 : 값을 반환하기 전에 연산
	iValue = 0;
	cout << iValue << endl;		// output : 0
	cout << ++iValue << endl;	// output : 1
	// 후위 연산자 : 값을 반환한 후에 연산
	iValue = 0;
	cout << iValue++ << endl;	// output : 0
	cout << iValue << endl;		// output : 1


	/**************************************************************
	* 대입 연산자
	***************************************************************/

	// <대입 연산자>
	iValue = 10;		// = : 오른쪽 값을 왼쪽의 변수에 대입

	// <복합 대입 연산자>
	// 이진 연산자(op)의 경우
	// x op= y 는 x = x op y 와 동일
	iValue += 5;		// iValue = iValue +5; 와 동일


	/**************************************************************
	* 비교 연산자
	***************************************************************/

	// <비교 연산자>
	bValue = 3 > 1;		
	bValue = 3 < 1;		
	bValue = 3 >= 1;	
	bValue = 3 <= 1;	
	bValue = 3 == 1;	
	bValue = 3 != 1;	// != : 두 연산자가 다를 경우 true


	/**************************************************************
	* 논리 연산자
	***************************************************************/

	// <논리 연산자>
	bValue = !false;			// ! (Not)	: 피연산자의 논리 부정을 반환
	bValue = true && false;		// &&(And)	: 두 피연산자가 모두 true 일 경우 true
	bValue = true || false;		// ||(Or)	: 두 피연산자가 모두 false 일 경우 false
	bValue = true ^ false;		// ^ (Xor)	: 두 피연산자가 다를 경우 true

	
	// <조건부 논리 연산자>
	// bValue = false && B;	: B가 무엇이든 상관없이 false 값을 반환
	// false && 에서 false가 결정되어 뒤의 연산을 진행하지 않음
	iValue = 10;
	bValue = false && (++iValue > 5);
	cout << iValue << endl; // output : 10 
	// bValue = true || A;	: A가 무엇이든 상관없이 true 값을 반환
	// true || 에서 true가 결정되어 뒤의 연산을 진행하지 않음
	iValue = 10;
	bValue = true || (++iValue > 5);
	cout << iValue << endl; // output : 10


	/*******************************************************
	* 비트 연산자
	* 
	* 다른 연산자에 비해 압도적으로 빠르다.
	********************************************************/

	// 8bit의 자료가 있다고 하자.
	//			용 풀 물 불
	// 0000     0  0  0  0
	// 이것처럼 비트마다 고유 속성을 주고 연산자를 사용하여 관리할 수 있다.

	// <단항 연산자>	
	iValue = ~0x35;			// ~ (비트 보수) : 데이터를 비트 단위로 보수 연산

	// <이진 연산자>
	iValue = 0x11 & 0x83;	// & (And) : 데이터를 비트 단위로 And 연산
	iValue = 0x11 | 0x83;	// | (Or)  : 데이터를 비트 단위로 Or 연산
	iValue = 0x11 ^ 0x83;	// ^ (Xor) : 데이터를 비트 단위로 Xor 연산

	// <비트 쉬프트 연산자>
	iValue = 0x20 << 2;		// << : 왼쪽 피연산자의 비트를 오른쪽 피연산자만큼 왼쪽으로 이동
	iValue = 0x20 >> 2;		// >> : 왼쪽 피연산자의 비트를 오른쪽 피연산자만큼 오른쪽으로 이동
	// << 2 == * 2^2 과 같은 결과지만 훨씬 빠르다.
	// 0b01010101  // 이진수는	0b~
	// 0123		   // 팔진수는	0
	// 0x957ABCDEF // 십육진수는	0x
	
	/*******************************************************
	* sizeof 연산자
	********************************************************/

	// <sizeof 연산자>
	// 자료형의 메모리 크기를 확인할 수 있음
	cout << "char형 데이터에 할당되는 메모리 크기는 " << sizeof(char) << " 바이트입니다." << endl;
	cout << "short형 데이터에 할당되는 메모리 크기는 " << sizeof(short) << " 바이트입니다." << endl;
	cout << "int형 데이터에 할당되는 메모리 크기는 " << sizeof(int) << " 바이트입니다." << endl;
	cout << "long long형 데이터에 할당되는 메모리 크기는 " << sizeof(long long) << " 바이트입니다." << endl;
	cout << "float형 데이터에 할당되는 메모리 크기는 " << sizeof(float) << " 바이트입니다." << endl;
	cout << "double형 데이터에 할당되는 메모리 크기는 " << sizeof(double) << " 바이트입니다." << endl;


	/************************************************************
	* 연산자 우선 순위
	* 
	* 여러 연산자가 있는 식에서 우선 순위가 높은 연산자가 먼저 계산
	*************************************************************/

	// <연산자 우선순위>
	// 1. 기본 연산		: a[i], x++, x--
	// 2. 단항 연산		: +x, -x, !x, ~x, ++x, --x, (Type)x
	// 3. 곱하기 연산	: x * y, x / y, x % y
	// 4. 더하기 연산	: x + y, x - y
	// 5. 시프트 연산	: x << y, x >> y
	// 6. 비교 연산		: x < y, x > y, x <= y, x >= y
	// 7. 같음 연산		: x == y, x != y
	// 8. 논리 AND 연산	: x & y, x && y
	// 9. 논리 XOR 연산	: x ^ y
	// 10. 논리 OR 연산	: x | y, x || y
	// 11. 대입 연산		: x = y, x op= y


	/**************************************************
	* 비트마스크 (BitMask)
	* 
	* 비트 연산자로 비트를 관리한다.
	* 메모리 소모를 줄일 수 있고, 연산처리 속도가 빠르다.
	***************************************************/
	const int FIRE		= 1	<< 0;
	const int WATER		= 1	<< 1;
	const int GRASS		= 1	<< 2;
	const int DRAGON	= 1 << 3;
	const int GHOST		= 1	<< 4;
	const int ROCK		= 1 << 5;
	const int FLYING	= 1 << 6;
	const int GROUND	= 1 << 7;
	// 상수는 대문자로 하는 것이 규칙

	int charmanderType = FIRE;
	int squirtleType = WATER;
	int bulbasaurType = GRASS;
	int charizardType = FIRE | DRAGON; // + 대신 |(Or)를 사용하는 것이 안전
	// 0001 | 1000 -> 1001 

	const int NONE		= 0 << 0;
	const int ELECTRIC	= 1 << 0;
	const int STUN		= 1 << 1;
	const int POSION	= 1 << 2;
	const int ICE		= 1 << 3;

	int status = NONE;
	status |= STUN; // 스턴 상태를 입력
	cout << status;
	status &= ~STUN; // 스턴 상태 삭제
	// 0010 &= ~(0010)
	// 0010 &= 1101
	// 0000
	if ((status & STUN) == STUN)
	{
		cout << " 스턴 상태입니다.";
	}// 스턴 상태 확인
}

// != 과 ^(Xor)의 차이 
// != 는 true false 이외에도 비교 가능
// ^ Xor은 true false만 비교

// (1+2) / 2		
// (1+2) * 0.5
// (1+2) >> 1