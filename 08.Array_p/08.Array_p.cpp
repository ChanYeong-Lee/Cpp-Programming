#include <iostream>

using namespace std;

void CopyArray(const int* array, int length);


int main()
{
	/***********************************************************************************
	* 배열 (Array)
	*
	* 같은 자료형의 여러 변수를 연속적으로 배치하여 저장한 데이터 유형
	* 배열을 구성하는 각 변수를 요소 (element)라고 하며, 요소가 연속적으로 모여 배열을 구성함
	************************************************************************************/

	// <배열 선언>
	// 자료형 배열이름[배열길이];
	int array0[5];					// int 자료형 변수 5개를 연속적으로 선언
	int numbers[3] = { 1, 3, 5 };		// int 자료형 변수 3개를 연속적으로 선언하면서 초기화
	int ints[] = { 5, 7, 9, 8 };	// 배열의 길이를 지정하지 않았지만 요소가 4개이므로 4 길이의 배열 선언
	int array1[4] = { 5 };			// { 0, 0, 0, 0, 5} 초기화를 한번만 진행하면 나머지 요소들에 0이 초기화됨

	// <인덱스 (index)>
	// 배열의 요소에 접근하기 위한 수단으로 [](하위연산자) 사이에 인덱스를 통해 접근
	// 인덱스는 0부터 시작하며, 길이가 N인 배열은 N-1까지 인덱스를 가질 수 있음
	// 왜 0부터인가? 쓰다보니 이게 더 편함
	cout << "numbers 배열의 1번째 요소는 " << numbers[0] << endl;
	cout << "numbers 배열의 3번째 요소는 " << numbers[2] << endl;
	cout << "array2 배열의 2번째 요소는 " << array1[1] << endl;

	// <배열의 길이>
	// 배열은 같은 자료형을 연속적으로 배치하는 방식이므로 (전체크기) / (하나의크기) 를 통해 길이 확인 가능
	// sizeof(배열이름) / sizeof(배열이름[0])
	// 왜 크기가 아니라 길이라고 하냐? 연속적으로 배치하면서 관리해서
	cout << "numbers 배열의 길이는 " << sizeof(numbers) / sizeof(numbers[0]) << endl;
	cout << "numbers 배열 주소는? " << &numbers << endl;
	cout << "numbers 배열 2번째 요소의 주소는? " << &numbers[1] << endl << endl;

	// <고정 배열>
	// 배열의 길이는 컴파일시 정해져 있어야 하며(지역변수니까) 변경할 수 없음
	// 프로그램 동작중(런타임)에 따라 달라질 수 있는 경우의 크기는 사용할 수 없음
	int array2[5];			// 사용 가능

	const int LENGTH = 5;
	int array3[LENGTH];		// 사용 가능(상수니까)

	int temp = 3;
	//int array4[temp];		// 사용 불가능

	// <동적 배열>
	// 동적 할당을 진행하면 런타임에 배열 크기를 원하는 만큼 할당할 수 있음
	// 런타임에 따라 달라질 수 있는 경우의 크기를 사용할 수 있음
	int size = 10;
	int* array5 = new int[size];	// 40 바이트를 할당받음

	delete[] array5;				// 배열 전체를 지울 필요가 있다.

	// <배열 사용시 주의사항>
	// 배열의 길이를 벗어나는 인덱스 사용시 의도치 않은 메모리 위치를 변경할 수 있음
	// 반드시 배열을 사용할 때 배열의 길이를 벗어나지 않는 인덱스를 사용해야함
	// array[-1] = 20;		// 주의! 프로그램을 손상시킬 수 있음
	// array[6] = 10; 

	// <다차원 배열>
	// 배열의 요소로 배열을 저장하도록 하여 여러 차원을 가진 배열처럼 사용할 수 있음
	int matrix[3][4];		// int 자료형의 변수를 4개 가진 배열을 3개 만들어 총 12개의 int를 가진 2차원 배열 선언
	/*
	[0][0]	[0][1]	[0][2]	[0][3]
	[1][0]	[1][1]	[1][2]	[1][3]
	[2][0]	[2][1]	[2][2]	[2][3]
	*/
	int table[3][2] = { {0, 1}, {2, 3}, {4, 5} };	// 이차원 배열 초기화
	int cube[2][3][4];							// 총 24개의 int 자료형 변수를 가진 3차원 배열

	// <배열과 반복>
	// 배열의 인덱스를 반복하여 증가시키며 사용하면 배열의 모든 요소를 반복 수행하는데 용이함
	int scores[] = { 84, 92, 76, 91, 56 };
	int length = sizeof(scores) / sizeof(scores[0]);
	int sum = 0;
	for (int i = 0; i < length; i++)
	{
		sum += scores[i];
	}

	// 배열이 위치를 찾는 방법
	// int A[300]; 
	// A[250] = 5;
	// 250번째 요소를 찾으려면 시작 주소 + 4(int 자료형 크기)*250(배열 순서)으로 주소를 찾아간다.


	/*************************************************************************************************
	* 배열과 포인터
	*
	* 같은 자료형을 연속적으로 배치하기 때문에 C++에서 배열과 포인터는 밀접한 관련이 있음
	* 배열이 많은 요소를 가지고 있어도 포인터를 활용하면 특정 요소에 빠르게 접근 가능
	**************************************************************************************************/

	// <포인터 산술연산>
	// 포인터에 산술연산(+, -)를 진행하는 경우 컴파일러는 자료형 크기만큼 곱하여 연산을 진행
	int iValue = 0;
	int* intPtr = &iValue;
	cout << "int 포인터 변수의 주소값 " << intPtr << endl;
	cout << "int 포인터 변수에 -1을 진행하는 경우 " << intPtr - 1 << endl;
	cout << "int 포인터 변수에 +1을 진행하는 경우 " << intPtr + 1 << endl << endl;

	double dValue = 0;
	double* doublePtr = &dValue;
	cout << "double 포인터 변수의 주소값 " << doublePtr << endl;
	cout << "double 포인터 변수에 -1을 진행하는 경우 " << doublePtr - 1 << endl;
	cout << "double 포인터 변수에 +1을 진행하는 경우 " << doublePtr + 1 << endl << endl;

	// <배열 이름과 주소값>
	// C++에서 배열 이름은 배열의 시작주소를 표현
	int array6[10] = { 1,2,3,4,5,6,7,8,9,10 };
	cout << "array6 배열의 첫번째 요소의 주소는 " << &array6[0] << endl;
	cout << "array6 배열의 첫번째 요소의 값은 " << array6[0] << endl;
	cout << "array6 배열의 이름을 통한 첫번째 요소의 주소는 " << array6 << endl;
	cout << "array6 배열의 이름을 통한 첫번째 요소 값은" << *(array6) << endl << endl;

	// <배열 요소의 위치 추측>
	// 배열은 같은 자료형을 연속적으로 배치하는 특징을 가지고 있기 때문에 배열 요소의 위치를 계산을 통해 추측할 수 있음
	// 가장 처음 배열 요소로 부터 자료형의 크기만큼 간격을 두고 주소값을 가진다를 계산할 수 있음
	cout << "array6 배열의 첫번째 요소의 주소는 " << &array6[0] << endl;
	cout << "array6 배열의 두번째 요소의 주소는 첫번쨰 요소로부터 자료형의 크기만큼 뒤에 있다고 계산할 수 있음" << endl;
	cout << "계산을 통해 확인한 두번째 요소의 주소는 " << &array6[0] << " + " << sizeof(array6[0]) << endl;
	cout << "array6 배열의 두번째 요소의 주소는 " << &array6[1] << endl << endl;

	// <배열의 구현 원리>
	// C++ 문법 중 [](하위연산자)는 포인터 주소를 이용한 구현으로 진행됨
	// 배열이름[인덱스] 는 *(배열이름 + 인덱스) 으로 변환되어 처리됨, 이는 시작주소 + 인덱스 * 자료형의크기
	cout << "array6 배열의 첫번째 요소의 주소 " << &array6[0] << " , " << array6 + 0 << endl;
	cout << "array6 배열의 두번째 요소의 주소 " << &array6[1] << " , " << array6 + 1 << endl;
	cout << "array6 배열의 세번째 요소의 주소 " << &array6[2] << " , " << array6 + 2 << endl << endl;

	cout << "array6 배열의 첫번째 요소의 값 " << array6[0] << " , " << *(array6 + 0) << endl;
	cout << "array6 배열의 두번째 요소의 값 " << array6[1] << " , " << *(array6 + 1) << endl;
	cout << "array6 배열의 세번째 요소의 값 " << array6[2] << " , " << *(array6 + 2) << endl;

	// array[0] -> *(array + 0)
	// array[1] -> *(array + 1)

	// <포인터 변수를 통한 배열 참조>
	// 배열은 포인터 변수를 이용하여 모든 동작이 가능
	// 단, 포인터 변수를 이용하는 경우 컴파일러가 배열 인덱스에 범위 밖에 대한 오류를 확인 할 수 없으니 주의
	const int* ptr = array6;		// 배열의 이름 자체가 배열의 시작 주소이기 때문에...
	cout << "포인터 변수를 통한 배열 요소 확인 " << ptr[0] << endl;
	// ptr[6] = 10      // 주의! 포인터 변수를 통한 인덱스 범위 밖 연산은 위험함
}

void CopyArray(const int* array, int length)	// const를 붙이는 경우 값을 전달했을 때 원본이 바뀌지 않는다
{
	for (int i = 0; i < length; i++)
	{
		array[i];
	}
}